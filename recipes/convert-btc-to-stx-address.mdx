---
id: convert-btc-to-stx-address
title: Convert a bitcoin address to its corresponding Stacks address
description: Every base58-encoded bitcoin address can be easily converted to its corresponding Stacks address. This conversion can be done on-chain by implementing the base58 encoding scheme in Clarity.
date: 2025.05.05
categories:
  - clarity
tags:
  - address
  - base58
  - c32
  - bitcoin
dependencies: []
files:
  - name: convert-btc-to-stx-address.clar
    path: contracts/convert-btc-to-stx-address.clar
    type: clarity
external_url: https://play.hiro.so/?epoch=3.1&snippet=KGRlZmluZS1jb25zdGFudCBBTExfSEVYIDB4MDAwMTAyMDMwNDA1MDYwNzA4MDkwQTBCMEMwRDBFMEYxMDExMTIxMzE0MTUxNjE3MTgxOTFBMUIxQzFEMUUxRjIwMjEyMjIzMjQyNTI2MjcyODI5MkEyQjJDMkQyRTJGMzAzMTMyMzMzNDM1MzYzNzM4MzkzQTNCM0MzRDNFM0Y0MDQxNDI0MzQ0NDU0NjQ3NDg0OTRBNEI0QzRENEU0RjUwNTE1MjUzNTQ1NTU2NTc1ODU5NUE1QjVDNUQ1RTVGNjA2MTYyNjM2NDY1NjY2NzY4Njk2QTZCNkM2RDZFNkY3MDcxNzI3Mzc0NzU3Njc3Nzg3OTdBN0I3QzdEN0U3RjgwODE4MjgzODQ4NTg2ODc4ODg5OEE4QjhDOEQ4RThGOTA5MTkyOTM5NDk1OTY5Nzk4OTk5QTlCOUM5RDlFOUZBMEExQTJBM0E0QTVBNkE3QThBOUFBQUJBQ0FEQUVBRkIwQjFCMkIzQjRCNUI2QjdCOEI5QkFCQkJDQkRCRUJGQzBDMUMyQzNDNEM1QzZDN0M4QzlDQUNCQ0NDRENFQ0ZEMEQxRDJEM0Q0RDVENkQ3RDhEOURBREJEQ0REREVERkUwRTFFMkUzRTRFNUU2RTdFOEU5RUFFQkVDRURFRUVGRjBGMUYyRjNGNEY1RjZGN0Y4RjlGQUZCRkNGREZFRkYpCihkZWZpbmUtY29uc3RhbnQgQkFTRTU4X0NIQVJTICIxMjM0NTY3ODlBQkNERUZHSEpLTE1OUFFSU1RVVldYWVphYmNkZWZnaGlqa21ub3BxcnN0dXZ3eHl6IikKKGRlZmluZS1jb25zdGFudCBTVFhfVkVSIDB4MTYxNDFhMTUpCihkZWZpbmUtY29uc3RhbnQgQlRDX1ZFUiAweDAwMDU2ZmM0KQoKKGRlZmluZS1jb25zdGFudCBFUlJfSU5WQUxJRF9DSEFSIChlcnIge2Vycm9yX2NvZGU6IHUxMjMxMjMsIHZhbHVlOiBub25lfSkpCihkZWZpbmUtY29uc3RhbnQgRVJSX1RPX1NIT1JUIChlcnIge2Vycm9yX2NvZGU6IHUyMzQyMzQsIHZhbHVlOiBub25lfSkpCihkZWZpbmUtY29uc3RhbnQgRVJSX0JBRF9DSEVDS1NVTSAoZXJyIHtlcnJvcl9jb2RlOiB1MzQ1MzQ1LCB2YWx1ZTogbm9uZX0pKQooZGVmaW5lLWNvbnN0YW50IEVSUl9JTlZBTElEX1ZFUlNJT04gKGVyciB7ZXJyb3JfY29kZTogdTQ1NjQ1NiwgdmFsdWU6IG5vbmV9KSkKKGRlZmluZS1jb25zdGFudCBMU1QgKGxpc3QpKQoKKGRlZmluZS1yZWFkLW9ubHkgKGJ0Yy10by1zdHggKGlucHV0IChzdHJpbmctYXNjaWkgNjApKSkKICAgIChsZXQgKAogICAgICAgIDs7IChtYXAgYjU4LXRvLXVpbnQgaW5wdXQpIGNvbnZlcnRzIGlucHV0IHN0cmluZyB0byBsaXN0IG9mIG9wdGlvbmFsIHVpbnQKICAgICAgICA7OyBJZiBpbnB1dCBjaGFyYWN0ZXIgaXMgcGFydCBvZiBCQVNFNTggYWxwaGFiZXQgd2UnbGwgZ2V0IGAoc29tZSBYKWAgd2hlcmUgYFhgIGlzIHBvc2l0aW9uIGluIHRoZSBhbHBoYWJldC4KICAgICAgICA7OyBPdGhlcndpc2Ugd2UnbGwgZ2V0IGBub25lYAogICAgICAgIDs7IFRoZW4gd2UgZmlsdGVyIG91dCBhbGwgYG5vbmVgIHZhbHVlcwogICAgICAgIDs7IE9uY2Ugd2UgZG8gdGhhdCwgd2UgY2FuIHNhZmVseSB1bndyYXAtcGFuaWMgYWxsIGAoc29tZSBYKWAgdmFsdWVzIHRvIGdldCBmaW5hbCBsaXN0IG9mIHVpbnQKICAgICAgICAoYjU4LW51bWJlcnMgKG1hcCB1bndyYXAtdWludCAoZmlsdGVyIGlzLXNvbWUtdWludCAobWFwIGI1OC10by11aW50IGlucHV0KSkpKQogICAgICAgIDs7IElmIGxlbmd0aCBvZiBgYjU4LW51bWJlcmAgaXMgc21hbGxlciB0aGFuIGxlbmd0aCBvZiBvdXIgaW5wdXQsIGl0IG1lYW5zIGlucHV0IGNvbnRhaW5zIGNoYXJhY3RlcnMgbm90IHByZXNlbnQgaW4gQkFTRTU4IGFscGhhYmV0LgogICAgICAgIDs7IChsZW4gYjU4LW51bWJlcnMpIGNhbid0IGJlIGdyZWF0ZXIgdGhhbiAobGVuIGlucHV0KSwgdGh1cyAiPj0iIGlzIHVzZWQgYXMgY2hlYXBlciB2ZXJzaW9uIG9mICJpcy1lcSIKICAgICAgICAodDEgKGFzc2VydHMhICg-PSAobGVuIGI1OC1udW1iZXJzKSAobGVuIGlucHV0KSkgRVJSX0lOVkFMSURfQ0hBUikpICAgCiAgICAgICAgOzsgVG8gY291bnQgbGVhZGluZyBvbmVzIHdlIGNhbiB1c2UgcHJvcGVydHkgb2YgYGluZGV4LW9mP2Agd2hpY2ggcmV0dXJucyB0aGUgKipmaXJzdCoqIGluZGV4IGF0IHdoaWNoIGVsZW1lbnQgY2FuIGJlIGZvdW5kLgogICAgICAgIDs7IEF0IHRoaXMgc3RhZ2Ugd2Ugb3BlcmF0ZSBvbiBpbnB1dCBjb252ZXJ0ZWQgdG8gQkFTRTU4IGFscGhhYmV0IGluZGV4ZXMsIHdlJ3JlIGxvb2tpbmcgZm9yIDAgaW5zdGVhZCBvZiAxLgogICAgICAgIDs7IENoYXJhY3RlciBhdCBpbmRleCAwID09IDEuCiAgICAgICAgOzsgRmlyc3Qgd2UgY29udmVydCBsaXN0IG9mIHVpbnQgdG8gbGlzdCBvZiBib29sZWFucywgd2hlcmUgYHRydWVgIHJlcHJlc2VudHMgb25lIGFuZCBgZmFsc2VgIGFueXRoaW5nIGVsc2UuCiAgICAgICAgOzsgQW5kIHRoZW4gd2l0aCBgaW5kZXgtb2Y_YCB3ZSBjYW4gZmluZCBpbmRleCB3aXRoIGBmYWxzZWAgdmFsdWUsIHdoaWNoIHRlbGxzIHVzIGhvdyBtYW55IGxlYWRpbmcgYHRydWVgIChvciBvbmVzKSBhcmUgaW4gdGhhdCBsaXN0LiAKICAgICAgICA7OyBJZiBgaW5kZXgtb2Y_YCB3b24ndCBmaW5kIGFueSBgZmFsc2VgIHZhbHVlLCBpdCBtZWFucyB0aGF0IHRoZXJlIGFyZSBqdXN0IGB0cnVlYCwgaGVuY2Ugd2UgZGVmYXVsdCB0byBgKGxlbiBpbnB1dClgLgogICAgICAgIChsZWFkaW5nLW9uZXMtY291bnQgKGRlZmF1bHQtdG8gKGxlbiBpbnB1dCkgKGluZGV4LW9mPyAobWFwIGlzLXplcm8gYjU4LW51bWJlcnMpIGZhbHNlKSkpCiAgICAgICAgCiAgICAgICAgOzsgd2UgY29udmVydCBsZWFkaW5nIG9uZXMgdG8gbGVhZGluZyB6ZXJvcwogICAgICAgIChsZWFkaW5nLXplcm9zIChtYXAgZm9yY2UtemVybyAodW53cmFwLXBhbmljIChzbGljZT8gYjU4LW51bWJlcnMgdTAgbGVhZGluZy1vbmVzLWNvdW50KSkpKQogICAgICAgIDs7IHdlICJjdXQiIGV2ZXJ5dGhpbmcgYnV0IGxlYWRpbmcgb25lcwogICAgICAgICh0by1kZWNvZGUgKGRlZmF1bHQtdG8gTFNUIChzbGljZT8gYjU4LW51bWJlcnMgbGVhZGluZy1vbmVzLWNvdW50IChsZW4gYjU4LW51bWJlcnMpKSkpCiAgICAgICAgCiAgICAgICAgOzsgY292ZXJ0IGJhc2UgNTggdmFsdWVzIHRvIGJhc2UgMjU2IG9uZXMKICAgICAgICAoZGVjb2RlZCAoY29uY2F0IChmb2xkIGRlY29kZS1vdXRlciB0by1kZWNvZGUgTFNUKSBsZWFkaW5nLXplcm9zKSkKICAgICAgICA7OyBjb252ZXJ0IGxpc3Qgb2YgdWludCB0byBidWZmIGNvbmNhdGVuYXRlZCBpbiByZXZlcnNlIG9yZGVyCiAgICAgICAgKGRlY29kZWQtaGV4IChmb2xkIHRvLWhleC1yZXYgZGVjb2RlZCAweCkpCiAgICAgICAgKGRlY29kZWQtaGV4LWxlbiAobGVuIGRlY29kZWQtaGV4KSkKICAgICAgIAogICAgICAgOzsgYW55dGhpbmcgc2hvcnRlciB0aGFuIDUgY2hhcmFjdGVycyBpcyBwb2ludGxlc3MgdG8gd29yayBhbnkgZnVydGhlcgogICAgICAgICh0MiAoYXNzZXJ0cyEgKDwgdTQgZGVjb2RlZC1oZXgtbGVuKSBFUlJfVE9fU0hPUlQpKQogICAgICAgIDs7IGV4dHJhY3QgZXZlcnl0aGluZyBidXQgbGFzdCA0IGJ5dGVzLCBwYXNzIGl0IHRocm91Z2ggZG91YmxlIHNoYTI2NSBhbmQgZXh0cmFjdCBmaXJzdCA0IGJ5dGVzCiAgICAgICAgKGFjdHVhbC1jaGVja3N1bSAodW53cmFwLXBhbmljIChzbGljZT8gKHNoYTI1NiAoc2hhMjU2ICh1bndyYXAtcGFuaWMgKHNsaWNlPyBkZWNvZGVkLWhleCB1MCAoLSBkZWNvZGVkLWhleC1sZW4gdTQpKSkpKSB1MCB1NCkpKQogICAgICAgIDs7IGV4dHJhY3QgbGFzdCA0IGJ5dGVzCiAgICAgICAgKGV4cGVjdGVkLWNoZWNrc3VtICh1bndyYXAtcGFuaWMgKHNsaWNlPyBkZWNvZGVkLWhleCAoLSBkZWNvZGVkLWhleC1sZW4gdTQpIGRlY29kZWQtaGV4LWxlbikpKQogICAgICAgIDs7IGNvbXBhcmUgZXhwZWN0ZWQgY2hlY2tzdW0gd2l0aCBhY3R1YWwsIGNhbGN1bGF0ZWQgb25lCiAgICAgICAgKHQzIChhc3NlcnRzISAoaXMtZXEgYWN0dWFsLWNoZWNrc3VtIGV4cGVjdGVkLWNoZWNrc3VtKSBFUlJfQkFEX0NIRUNLU1VNKSkKCiAgICAgICAgOzsgZXh0cmFjdCBmaXJzdCBieXRlIGFuZCB0cnkgdG8gbWF0Y2ggaXQgd2l0aCBCVENfVkVSIGFuZCB0aGVuIFNUWF9WRVIKICAgICAgICAodmVyc2lvbiAodW53cmFwLXBhbmljIChlbGVtZW50LWF0PyBTVFhfVkVSICh1bndyYXAhIChpbmRleC1vZj8gQlRDX1ZFUiAodW53cmFwLXBhbmljIChlbGVtZW50LWF0PyBkZWNvZGVkLWhleCB1MCkpKSBFUlJfSU5WQUxJRF9WRVJTSU9OKSkpKQogICAgICAgICkKICAgICAgICA7OyBjb25zdHJ1Y3QgcHJpbmNpcGFsCiAgICAgICAgKHByaW5jaXBhbC1jb25zdHJ1Y3Q_IHZlcnNpb24gKHVud3JhcC1wYW5pYyAoYXMtbWF4LWxlbj8gKHVud3JhcC1wYW5pYyAoc2xpY2U_IGRlY29kZWQtaGV4IHUxICgtIGRlY29kZWQtaGV4LWxlbiB1NCkpKSB1MjApKSkKICAgICkKKQoKKGRlZmluZS1yZWFkLW9ubHkgKGI1OC10by11aW50ICh4IChzdHJpbmctYXNjaWkgMSkpKSAoaW5kZXgtb2Y_IEJBU0U1OF9DSEFSUyB4KSkKKGRlZmluZS1yZWFkLW9ubHkgKGlzLXNvbWUtdWludCAoeCAob3B0aW9uYWwgdWludCkpKSAoaXMtc29tZSB4KSkKKGRlZmluZS1yZWFkLW9ubHkgKHVud3JhcC11aW50ICh4IChvcHRpb25hbCB1aW50KSkpICh1bndyYXAtcGFuaWMgeCkpCihkZWZpbmUtcmVhZC1vbmx5IChpcy16ZXJvICh4IHVpbnQpKSAoaXMtZXEgeCB1MCkpCihkZWZpbmUtcmVhZC1vbmx5IChmb3JjZS16ZXJvICh4IHVpbnQpKSB1MCkKCihkZWZpbmUtcmVhZC1vbmx5ICh0by1oZXgtcmV2ICh4IHVpbnQpIChvdXQgKGJ1ZmYgMzMpKSkKICAgICh1bndyYXAtcGFuaWMgKGFzLW1heC1sZW4_IChjb25jYXQgKHVud3JhcC1wYW5pYyAoZWxlbWVudC1hdD8gQUxMX0hFWCB4KSkgb3V0KSB1MzMpKQopCgooZGVmaW5lLXJlYWQtb25seSAoZGVjb2RlLW91dGVyICh4IHVpbnQpIChvdXQgKGxpc3QgMzMgdWludCkpKQogICAgKGxldCAoCiAgICAgICAgKG5ldy1vdXQgKGZvbGQgdXBkYXRlLW91dCBvdXQgKGxpc3QgeCkpKQogICAgICAgIChjYXJyeS10by1wdXNoIChmb2xkIGNhcnJ5LXB1c2ggMHgwMDAwIChsaXN0ICh1bndyYXAtcGFuaWMgKGVsZW1lbnQtYXQ_IG5ldy1vdXQgdTApKSkpKQogICAgICAgICkgICAKICAgICAgICAoY29uY2F0IAogICAgICAgICAgICAoZGVmYXVsdC10byBMU1QgKHNsaWNlPyBuZXctb3V0IHUxIChsZW4gbmV3LW91dCkpKQogICAgICAgICAgICAoZGVmYXVsdC10byBMU1QgKHNsaWNlPyBjYXJyeS10by1wdXNoIHUxIChsZW4gY2FycnktdG8tcHVzaCkpKQogICAgICAgICkKICAgICkKKQoKKGRlZmluZS1yZWFkLW9ubHkgKHVwZGF0ZS1vdXQgKHggdWludCkgKG91dCAobGlzdCAzMCB1aW50KSkpCiAgICA7OyBjYXJyeSArPSB4ICogNTg7CiAgICAobGV0ICgoY2FycnkgKCsgKHVud3JhcC1wYW5pYyAoZWxlbWVudC1hdD8gb3V0IHUwKSkgICgqIHggdTU4KSkpKQogICAgICAgICh1bndyYXAtcGFuaWMgKGFzLW1heC1sZW4_IChjb25jYXQgCiAgICAgICAgICAgIChsaXN0ICgvIGNhcnJ5IHUyNTYpKSA7OyBuZXcgY2FycnkKICAgICAgICAgICAgKGNvbmNhdAogICAgICAgICAgICAgICAgKGRlZmF1bHQtdG8gTFNUIChzbGljZT8gb3V0IHUxIChsZW4gb3V0KSkpIDs7IGV4aXN0aW5nIGxpc3QKICAgICAgICAgICAgICAgIChsaXN0IChtb2QgY2FycnkgdTI1NikpIDs7IG5ldyBlbGVtZW50CiAgICAgICAgICAgICkKICAgICAgICApIHUzMCkpCiAgICApCikKCgooZGVmaW5lLXJlYWQtb25seSAoY2FycnktcHVzaCAoeCAoYnVmZiAxKSkgKG91dCAobGlzdCAzIHVpbnQpKSkKICAgIChsZXQgKChjYXJyeSAodW53cmFwLXBhbmljIChlbGVtZW50LWF0PyBvdXQgdTApKSkpICAgICAgCiAgICAgICAgKGlmICg-IGNhcnJ5IHUwKQogICAgICAgICAgICAodW53cmFwLXBhbmljIChhcy1tYXgtbGVuPyAoY29uY2F0CiAgICAgICAgICAgICAgICAobGlzdCAoLyBjYXJyeSB1MjU2KSkgOzsgbmV3IGNhcnJ5CiAgICAgICAgICAgICAgICAoY29uY2F0CiAgICAgICAgICAgICAgICAgICAgKGRlZmF1bHQtdG8gTFNUIChzbGljZT8gb3V0IHUxIChsZW4gb3V0KSkpIDs7IGV4aXN0aW5nIGxpc3QKICAgICAgICAgICAgICAgICAgICAobGlzdCAobW9kIGNhcnJ5IHUyNTYpKSA7OyBuZXcgZWxlbWVudAogICAgICAgICAgICAgICAgKQogICAgICAgICAgICApIHUzKSkKICAgICAgICAgICAgb3V0CiAgICAgICAgKQogICAgKQop
---

```clarity
(define-constant ALL_HEX 0x000102030405060708090A0B0C0D0E0F101112131415161718191A1B1C1D1E1F202122232425262728292A2B2C2D2E2F303132333435363738393A3B3C3D3E3F404142434445464748494A4B4C4D4E4F505152535455565758595A5B5C5D5E5F606162636465666768696A6B6C6D6E6F707172737475767778797A7B7C7D7E7F808182838485868788898A8B8C8D8E8F909192939495969798999A9B9C9D9E9FA0A1A2A3A4A5A6A7A8A9AAABACADAEAFB0B1B2B3B4B5B6B7B8B9BABBBCBDBEBFC0C1C2C3C4C5C6C7C8C9CACBCCCDCECFD0D1D2D3D4D5D6D7D8D9DADBDCDDDEDFE0E1E2E3E4E5E6E7E8E9EAEBECEDEEEFF0F1F2F3F4F5F6F7F8F9FAFBFCFDFEFF)
(define-constant BASE58_CHARS "123456789ABCDEFGHJKLMNPQRSTUVWXYZabcdefghijkmnopqrstuvwxyz")
(define-constant STX_VER 0x16141a15)
(define-constant BTC_VER 0x00056fc4)

(define-constant ERR_INVALID_CHAR (err {error_code: u123123, value: none}))
(define-constant ERR_TO_SHORT (err {error_code: u234234, value: none}))
(define-constant ERR_BAD_CHECKSUM (err {error_code: u345345, value: none}))
(define-constant ERR_INVALID_VERSION (err {error_code: u456456, value: none}))
(define-constant LST (list))

(define-read-only (btc-to-stx (input (string-ascii 60)))
    (let (
        ;; (map b58-to-uint input) converts input string to list of optional uint
        ;; If input character is part of BASE58 alphabet we'll get `(some X)` where `X` is position in the alphabet.
        ;; Otherwise we'll get `none`
        ;; Then we filter out all `none` values
        ;; Once we do that, we can safely unwrap-panic all `(some X)` values to get final list of uint
        (b58-numbers (map unwrap-uint (filter is-some-uint (map b58-to-uint input))))
        ;; If length of `b58-number` is smaller than length of our input, it means input contains characters not present in BASE58 alphabet.
        ;; (len b58-numbers) can't be greater than (len input), thus ">=" is used as cheaper version of "is-eq"
        (t1 (asserts! (>= (len b58-numbers) (len input)) ERR_INVALID_CHAR))
        ;; To count leading ones we can use property of `index-of?` which returns the **first** index at which element can be found.
        ;; At this stage we operate on input converted to BASE58 alphabet indexes, we're looking for 0 instead of 1.
        ;; Character at index 0 == 1.
        ;; First we convert list of uint to list of booleans, where `true` represents one and `false` anything else.
        ;; And then with `index-of?` we can find index with `false` value, which tells us how many leading `true` (or ones) are in that list.
        ;; If `index-of?` won't find any `false` value, it means that there are just `true`, hence we default to `(len input)`.
        (leading-ones-count (default-to (len input) (index-of? (map is-zero b58-numbers) false)))

        ;; we convert leading ones to leading zeros
        (leading-zeros (map force-zero (unwrap-panic (slice? b58-numbers u0 leading-ones-count))))
        ;; we "cut" everything but leading ones
        (to-decode (default-to LST (slice? b58-numbers leading-ones-count (len b58-numbers))))

        ;; covert base 58 values to base 256 ones
        (decoded (concat (fold decode-outer to-decode LST) leading-zeros))
        ;; convert list of uint to buff concatenated in reverse order
        (decoded-hex (fold to-hex-rev decoded 0x))
        (decoded-hex-len (len decoded-hex))

       ;; anything shorter than 5 characters is pointless to work any further
        (t2 (asserts! (< u4 decoded-hex-len) ERR_TO_SHORT))
        ;; extract everything but last 4 bytes, pass it through double sha265 and extract first 4 bytes
        (actual-checksum (unwrap-panic (slice? (sha256 (sha256 (unwrap-panic (slice? decoded-hex u0 (- decoded-hex-len u4))))) u0 u4)))
        ;; extract last 4 bytes
        (expected-checksum (unwrap-panic (slice? decoded-hex (- decoded-hex-len u4) decoded-hex-len)))
        ;; compare expected checksum with actual, calculated one
        (t3 (asserts! (is-eq actual-checksum expected-checksum) ERR_BAD_CHECKSUM))

        ;; extract first byte and try to match it with BTC_VER and then STX_VER
        (version (unwrap-panic (element-at? STX_VER (unwrap! (index-of? BTC_VER (unwrap-panic (element-at? decoded-hex u0))) ERR_INVALID_VERSION))))
        )
        ;; construct principal
        (principal-construct? version (unwrap-panic (as-max-len? (unwrap-panic (slice? decoded-hex u1 (- decoded-hex-len u4))) u20)))
    )
)

(define-read-only (b58-to-uint (x (string-ascii 1))) (index-of? BASE58_CHARS x))
(define-read-only (is-some-uint (x (optional uint))) (is-some x))
(define-read-only (unwrap-uint (x (optional uint))) (unwrap-panic x))
(define-read-only (is-zero (x uint)) (is-eq x u0))
(define-read-only (force-zero (x uint)) u0)

(define-read-only (to-hex-rev (x uint) (out (buff 33)))
    (unwrap-panic (as-max-len? (concat (unwrap-panic (element-at? ALL_HEX x)) out) u33))
)

(define-read-only (decode-outer (x uint) (out (list 33 uint)))
    (let (
        (new-out (fold update-out out (list x)))
        (carry-to-push (fold carry-push 0x0000 (list (unwrap-panic (element-at? new-out u0)))))
        )
        (concat
            (default-to LST (slice? new-out u1 (len new-out)))
            (default-to LST (slice? carry-to-push u1 (len carry-to-push)))
        )
    )
)

(define-read-only (update-out (x uint) (out (list 30 uint)))
    ;; carry += x * 58;
    (let ((carry (+ (unwrap-panic (element-at? out u0))  (* x u58))))
        (unwrap-panic (as-max-len? (concat
            (list (/ carry u256)) ;; new carry
            (concat
                (default-to LST (slice? out u1 (len out))) ;; existing list
                (list (mod carry u256)) ;; new element
            )
        ) u30))
    )
)


(define-read-only (carry-push (x (buff 1)) (out (list 3 uint)))
    (let ((carry (unwrap-panic (element-at? out u0))))
        (if (> carry u0)
            (unwrap-panic (as-max-len? (concat
                (list (/ carry u256)) ;; new carry
                (concat
                    (default-to LST (slice? out u1 (len out))) ;; existing list
                    (list (mod carry u256)) ;; new element
                )
            ) u3))
            out
        )
    )
)
```
